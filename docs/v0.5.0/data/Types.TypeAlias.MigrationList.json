{"id":84,"name":"MigrationList","kind":4194304,"kindString":"Type alias","flags":{},"comment":{"summary":[{"kind":"text","text":"A list of migrations to be executed.\nThe key is the target version number, and the value is the migration callback.\nEg. "},{"kind":"code","text":"`{ 2: (migration) => { ... } }`"},{"kind":"text","text":" will execute the migration callback when the current database version is smaller than 2.\n\nBecause of this a key of "},{"kind":"code","text":"`1`"},{"kind":"text","text":" will only be executed on the first migration, this can be used to populate the database with initial data.\n\nA migration callback receives a "},{"kind":"inline-tag","tag":"@link","text":"MigrationContext","target":177},{"kind":"text","text":" object as its only argument.\nThis object contains a transaction to be used for the migration.\n\nIt is expected for the callback to create Model classes that represent the table's state in between these two versions.\nThe fields aren't actually used by W-ORM in this scenario, and only serve to improve the typing within the migration.\nThe "},{"kind":"inline-tag","tag":"@link","text":"Model","target":195},{"kind":"text","text":" methods can be then used to manipulate the data.\nIt is very important to use the transaction provided by the migration context, otherwise the migration will hang forever."}],"blockTags":[{"tag":"@example","content":[{"kind":"code","text":"```ts\nconst migrations: MigrationList = {\n   2: async (migration) => {\n     class Test extends Model {\n       id!: number\n       name!: string\n     }\n\n     await Test.forEach(async (instance, tx) => {\n       instance.name = `${instance.id} name`\n       await instance.save(tx)\n     }, migration.tx)\n\n     const test = await Test.get(69, migration.tx)\n     await test?.delete(migration.tx)\n   },\n }\n```"}]}]},"children":[],"sources":[{"fileName":"types.ts","fullFileName":"/home/runner/work/w-orm/w-orm/src/types.ts","line":128,"character":12,"url":"https://github.com/D34DPlayer/w-orm/blob/d03bd3b/src/types.ts#L128"}],"type":{"type":"reference","typeArguments":[{"type":"intrinsic","name":"number"},{"type":"reference","id":80,"name":"Migration"}],"name":"Record","qualifiedName":"Record","package":"typescript"},"is":{"declaration":true},"location":{"query":"Types.TypeAlias.MigrationList","hash":""},"text":{"comment":"<p>A list of migrations to be executed.\nThe key is the target version number, and the value is the migration callback.\nEg. <code>{ 2: (migration) =&gt; { ... } }</code> will execute the migration callback when the current database version is smaller than 2.</p>\n<p>Because of this a key of <code>1</code> will only be executed on the first migration, this can be used to populate the database with initial data.</p>\n<p>A migration callback receives a <a href=\"177\">MigrationContext</a> object as its only argument.\nThis object contains a transaction to be used for the migration.</p>\n<p>It is expected for the callback to create Model classes that represent the table&#39;s state in between these two versions.\nThe fields aren&#39;t actually used by W-ORM in this scenario, and only serve to improve the typing within the migration.\nThe <a href=\"195\">Model</a> methods can be then used to manipulate the data.\nIt is very important to use the transaction provided by the migration context, otherwise the migration will hang forever.</p>\n<h5>Example:</h5><pre><code class=\"language-ts\"><span class=\"pl-k\">const</span> <span class=\"pl-c1\">migrations</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">MigrationList</span> <span class=\"pl-k\">=</span> {\n   <span class=\"pl-c1\">2</span>: <span class=\"pl-k\">async</span> (<span class=\"pl-v\">migration</span>) <span class=\"pl-k\">=></span> {\n     <span class=\"pl-k\">class</span> <span class=\"pl-en\">Test</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Model</span> {\n       <span class=\"pl-v\">id</span><span class=\"pl-k\">!:</span> <span class=\"pl-c1\">number</span>\n       <span class=\"pl-v\">name</span><span class=\"pl-k\">!:</span> <span class=\"pl-c1\">string</span>\n     }\n\n     <span class=\"pl-k\">await</span> <span class=\"pl-smi\">Test</span>.<span class=\"pl-c1\">forEach</span>(<span class=\"pl-k\">async</span> (<span class=\"pl-v\">instance</span>, <span class=\"pl-v\">tx</span>) <span class=\"pl-k\">=></span> {\n       <span class=\"pl-smi\">instance</span>.<span class=\"pl-c1\">name</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">`</span>${<span class=\"pl-smi\">instance</span>.<span class=\"pl-c1\">id</span>} name<span class=\"pl-pds\">`</span></span>\n       <span class=\"pl-k\">await</span> <span class=\"pl-smi\">instance</span>.<span class=\"pl-en\">save</span>(<span class=\"pl-smi\">tx</span>)\n     }, <span class=\"pl-smi\">migration</span>.<span class=\"pl-smi\">tx</span>)\n\n     <span class=\"pl-k\">const</span> <span class=\"pl-c1\">test</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-smi\">Test</span>.<span class=\"pl-c1\">get</span>(<span class=\"pl-c1\">69</span>, <span class=\"pl-smi\">migration</span>.<span class=\"pl-smi\">tx</span>)\n     <span class=\"pl-k\">await</span> <span class=\"pl-smi\">test</span>?.<span class=\"pl-c1\">delete</span>(<span class=\"pl-smi\">migration</span>.<span class=\"pl-smi\">tx</span>)\n   },\n }\n</code></pre>\n"},"parentId":2}
